DistributedFixedIndegree(
  int source_host[], int n_target_host, T1 source[], int n_source[],
  int target_host[], int n_source_host, T2 target[], int n_target[],
  int indegree, SynSpec syn_spec)
{

  for (int ith=0; ith<n_target_host; ith++) {
    if (target_host[ith] == this_host_) {
  
      // if T2 is a pointer copy target[ith] from CPU to GPU memory
      // (needs methods overloading plus template specialization,
      //  see Connect commands in connect_rules.cu)
    
      int64_t n_new_conn_tot = n_target[ith]*indegree;

      // Create new connection blocks as needed

      // Cumulative sum of n_source: n_source_cumul
      // total number of source nodes:
      n_source_tot = n_source_cumul[n_source_host]

      // CUDA kernel to create source node indexs
      // (each extracted randomly in the range from 0 to n_source_tot-1)
      // and target node indexes (each element of target[] repeated
      // indegree times, stored in the connection blocks
      // in reverse position, i.e. target in the conn_key part
      // source in the conn_value part
      // because the source index can require more than 32 bits
      // The code should be similar to the already present one for
      // fixed indegree connections

      // Sort the connections in the blocks with the COPASS algorithm as
      // usual but using the conn_value as key and the conn_key as value

      // Locate (search) each element of the cumulative sum array
      // n_source_cumul in the conn_value blocks, in order to partition the
      // connections according to the source host
      // It's fine to do it with a loop, no need for parallelizing

      for (int ish=0, ish<n_source_host; ish++) {
        n_new_conn = search(n_source_cumul[ish+1],
	                    conn_value[n_conn:n_conn+n_new_conn_tot)
			    
        // Kernel that subtracts n_source_cumul[ish] from all conn_values
	// from n_conn to n_conn + n_new_conn - 1
	// and swaps conn_value with conn_key

	// do a regular RemoteConnect with source host n. ish
	// using a new connection rule that uses already created connections
	// filled only with source node relative indexes and target node
	// indexes and fills them with weights, delays, syn_geoups, ports
      }
      


      
    
  
